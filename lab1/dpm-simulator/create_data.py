# Create_data.py
# This script will observe the output generated by the dpm_simulator
# This script will consider only the IDLE state as the OFF state

import os
import argparse
import subprocess
import pandas as pd

from analyze_psm import Tbe_data

# Get workload num from user
parser = argparse.ArgumentParser(description="Run DPM simulations and create a summary table")
parser.add_argument("--workload", type=int, default=1, choices=[1, 2],
                    help="workload to run (1 or 2)")
parser.add_argument("--timeoutpolicy", type=str, default="I", choices=["I", "S"],
                    help="Timeout policy to run (I or S)")
args = parser.parse_args()
wl_num = str(args.workload)
to_pol = str(args.timeoutpolicy)

simulator_script    = f"./results_script_nofile.sh"
result_dir          = f"./results/workload{wl_num}"
result_filename     = f"{result_dir}/table.csv"

os.makedirs(result_dir, exist_ok=True)

print("Working on workload ", wl_num) 

# Retrieving breakeven times
tmp = Tbe_data()
R2I_Tbe = tmp[0]    # Run 2 Idle BE
R2S_Tbe = tmp[1]    # Run 2 Sleep BE (Useless at the moment)

if(to_pol == "I"):
    TimeOut = R2I_Tbe
elif(to_pol == "S"):
    TimeOut = R2S_Tbe


print("Selected TimeOut policy: ", to_pol)

# Setting different Timeouts based on BreakEven Time and results obtained
exit_cond = 0
i = 0

with open(result_filename, "w") as result_table:

    result_table.write("Timeout,Transitions,Energy\n")

    while exit_cond != 1:
        result = subprocess.run(
            ["bash", simulator_script, wl_num, str(TimeOut * i)],
            capture_output=True,
            text=True,
            check=True
        )
        lines = [line.strip() for line in result.stdout.splitlines() if line.strip()]
        transition_num  = int(lines[0])
        energy_cons     = float(lines[1])
        print("timeout: %10.2f, transition num: %5d, energy consumption: %5.5f" % (TimeOut * i, transition_num, energy_cons)) 
        result_table.write(f"{TimeOut*i}, {transition_num}, {energy_cons}\n")
        result_table.flush()

        
        transition_i = transition_num
        if i != 0:
            if transition_i_1 - transition_i == 0:      # In case the number of transition is the same
                i = i * 2
            else:
                i = i + 1
        else:
            i = i + 1
        transition_i_1 = transition_i   # Number of transition of previous timeout
        
        if (transition_num == 0):
            exit_cond = 1


df = pd.read_csv(result_filename)
df['Timeout'] = pd.to_numeric(df['Timeout'], errors='coerce')
df = df.sort_values(by='Timeout').reset_index(drop=True)
df.to_csv(result_filename, index=False)

print("\nSummary Table")
print(df)
